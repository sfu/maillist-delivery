#!/usr/bin/perl
#
# This script manages the Sendmail Quarantine queue and whitelist
# The queue is used by the rate limiting milter, which flags messages
# for quarantine if the sender sends to too many non-sfu recipients in
# a day. 
#
# Create an xinetd entry to invoke this script when connections 
# come in on the desired port. For additional security, use xinetd's
# config to limit what IP addresses can connect

use Socket;
use Getopt::Std;
use JSON;
use DB_File;

# List of services that could be running on this host. We use this to
# determine which commands to allow
my %service;
@services = ("sendmail","mailfromd");
getServices();

# List of files we're allowed to alter remotely
$files = { accessdynamic =>
			{
				path => "/etc/mail/access.dynamic",
				type => "access", # file type: sendmail access file
				access => "rwa", # access: r=read, w=overwrite, a=append
				postcmd => "cat /etc/mail/access.static /etc/mail/access.dynamic > /etc/mail/access; /usr/bin/makemap hash /etc/mail/access.db < /etc/mail/access"
			},
			accessstatic =>
			{
				path => "/etc/mail/access.static",
				type => "access",
				access => "ra",
				postcmd => "cat /etc/mail/access.static /etc/mail/access.dynamic > /etc/mail/access; /usr/bin/makemap hash /etc/mail/access.db < /etc/mail/access"
			},
			access =>
			{
				path => "/etc/mail/access.db",
				type => "db", # file type: standard Berkeley DB file
				access => "r",
			},
			virtusertable =>
			{
				path => "/etc/mail/virtusertable.db",
				type => "db",
				access => "rwa",
				hastext => "1", # also update text version of file (name minus the ".db" suffix)
			}, 
			mailfromdwhitelist =>
			{
				path => "/usr/local/var/mailfromd/whitelist.db",
				type => "db",
				access => "rwa",
				hastext => "1",
			}
		 };

# Only accept connections from authorized hosts
$| = 1;
$sockaddr = 'S n a4 x8';
$peersockaddr = getpeername(STDIN);
($family, $port, $peeraddr) = unpack($sockaddr, $peersockaddr);
($a, $b, $c, $d) = unpack('C4', $peeraddr);
$peer = "$a.$b.$c.$d";
($peername, $aliases, $addrtype, $length, @addrs) = gethostbyaddr($peeraddr, AF_INET);

if (!( $peername =~ /^garibaldi3.tier2.sfu.ca/ ||
       $peername =~ /^garibaldi4.tier2.sfu.ca/ ||
       $peername =~ /^hatzic-stage[12].tier2.sfu.ca/ ||
       $peername =~ /^mailgw1.tier2.sfu.ca/ ||
       $peername =~ /^mailgw2.tier2.sfu.ca/ ||
       $peername =~ /^pobox1.tier2.sfu.ca/ ||
       $peername =~ /^pobox2.tier2.sfu.ca/ ||  
       $peername =~ /^rm-rstar1.nfs.sfu.ca/ ||
       $peername =~ /^rm-rstar2.nfs.sfu.ca/ )) { 
    print "Bye $peername!\n";
    exit 0; 
} 

print "ok\n";

$cmd = <>;
$cmd =~ s/[\r\n]+//;


#sub usage()
#{
#    print <<EOF;
#Usage:
#   quarantine [-q]                - View the quarantine queue
#   quarantine -w [-a|-d  address] - View or manage the whitelist
#   quarantine -v Message-ID       - View a quarantined message
#   quarantine -d regex            - Delete messages from the quarantine queue on both rm-rstar1&2
#   quarantine -r QueueID          - Release message with this Queue Identifier
#
#You must be ROOT for all but the first variant
#
#EOF
#}


# Human-readable queue summary
if ($cmd eq "queue")
{
	$result = `mailq -qQ`;
	print $result;
	exit 0;
}

if ($cmd =~ "^(queuebb|queuejson)")
{
	printQueue($cmd);
	exit 0;
}

if ($cmd =~ /^view ([\w\d]+)$/)
{
	# View a quarantined message
	$qid = $1;
	system("find /var/spool/mqueue -name hf$qid -exec cat '{}' \\;; find /var/spool/mqueue -name df$qid -exec cat '{}' \\;");
	exit 0;
}

if ($cmd =~ /^delete (.*)$/)
{
	$regex = $1;
	system("/usr/local/etc/cleanqueue -q \"$regex\"");
	exit 0;
}

if ($cmd =~ /^deleteI ([\w\d]+)$/)
{
	$qid = $1;
	system("find /var/spool/mqueue \\( -name hf$qid -o -name df$qid \\) -exec rm '{}' \\;");
	exit 0;
}

if ($cmd =~ /^release([IRS]) (.*)$/)
{
	$what = $2;
	$type = $1;
	system("/usr/sbin/sendmail -qQ -Q -q$type$what");
	exit 0;
}

if ($cmd =~ /^get ([a-z]+)$/)
{
	$what = $1;
	if (defined($file->{$what}))
	{
		$res = getFile($what);
		print $res;
	}
	else
	{
		print "unknown entity\n";
	}
	exit 0;
}

if ($cmd =~ /^test$/)
{
	$jsonobj = JSON->new->allow_nonref;
	print jsonobj->encode($files);
	exit 0;
}


print "unknown command: $cmd\n";
exit 0;


# Print summary for Xymon/big Brother
# First line is number of quarantine'd msgs
# If non-zero, include summary of users, msgs, recipients, subjects
#
# Now overloaded to handle json output for a web friendly version. Parse QF files to populate hash for json
# QF looks like this:
# V8
# T1481617801
# K1481665051
# N16
# P1475902
# I253/0/783874
# B7BIT
# MDeferred: Connection refused by sfuchildcare.ca.
# Fwbs
# $_[119.28.98.251]
# $rESMTP
# $ssawadika13.top
# ${daemon_flags}
# ${if_addr}192.168.99.109
# S<bounce-452-96378416-452-248@sawadika13.top>


sub printQueue()
{
	my $cmd = shift;
	$view = 0; $json = ($cmd=~"^queuejson") ? 1 : 0;
	if ($cmd =~ /^queuebb -v (.*)$/)
	{
	    $view = $1;
	}
	if ($cmd =~ /^queuejson (.*)$/)
	{
	    $limit = $1;
	    $limit = 0 if ($limit < 0);
	}
	@qfiles = `find /var/spool/mqueue -name "hf*" -print`;
	$total = @qfiles;
	print "$total\n" if (!$json);
	my %jsondata;
	$jsondata{total} = $total;
	if ($total)
	{
	    $count = 0;
	    $jsondata{messages} = [];
	    foreach $qf (@qfiles)
	    {
			my (%qdata);
			$qf =~ m/\/hf(.+)$/;
			$qid = $1;
			$qdata{id} = $qid;
			push(@qids, $qid);
			open(QF,$qf);
			@lines = <QF>;
			close QF;
			foreach $l (@lines)
			{
			    chomp;
			    if ($l =~ /^r/)
			    {
			    	$recips{$qid}++;
			    }
			    elsif ($l =~ /\$_(.*)/)
			    {
					$hosts{$1} .= "$qid:";
					$qdata{host} = $1;
			    }
			    elsif ($l =~ /X-Authenticated-User: (.*)/)
			    {
					$qid{$1} .= "$qid:";
					$qdata{authuser} = $1;
			    }
			    elsif ($l =~ /Subject: (.*)/)
			    {
					$subject{$qid} = $1;
					$qdata{subject} = $1;
			    }
			    elsif ($l =~ /^T(\d+)$/)
			    {
					$qdata{ctime} = $1;
			    }
			    elsif ($l =~ /^K(\d+)$/)
			    {
					$qdata{mtime} = $1;
			    }
			    elsif ($l =~ /^S<?([^>]+)>?/)
			    {
					$qdata{sender} = $1;
			    }
			}
			$qdata{recips} = $recips{$qid};
			push(@{$jsondata{messages}},\%qdata);
			$count++;
			last if ($count == $limit);
	    }

	    if (!$json)
	    {
	        # Summarize results
	        print "Unique SFUConnect users seen:\n" if (!$view);
	        foreach $user (keys %qid)
	        {
		    @msgs = split(/:/,$qid{$user});
		    if ($view) { 
		        next if ($user ne $view); 
		        $qid = $msgs[0];
		        system("find /var/spool/mqueue -name hf$qid -exec cat '{}' \\;; find /var/spool/mqueue -name df$qid -exec cat '{}' \\;");
		        exit 0;
		    }
		    $count = @msgs;
		    $recips = 0;
		    foreach (@msgs) { $recips += $recips{$_}; }
		    print "Sender: $user\tMsgs: $count\tRecipients: $recips\n";
		    print "  Sample: $msgs[0]\n";
		    print "  Subject: ",$subject{$msgs[0]},"\n";
	        }
    
	        print "Unique hosts seen:\n";
	        foreach $host (keys %hosts)
	        {
		    @msgs = split(/:/,$hosts{$host});
		    $count = @msgs;
		    $recips = 0;
		    foreach (@msgs) { $recips += $recips{$_}; }
		    print "Host: $host\tMsgs: $count\tRecipients: $recips\n";
		    print "  Sample: $msgs[0]\n";
		    print "  Subject: ",$subject{$msgs[0]},"\n";
	        }
	    }
	}
	if ($json)
	{
	    $jsonobj = JSON->new->allow_nonref;
	    print $jsonobj->encode(\%jsondata),"\n";
	}
}

# Determine which services are running on this host by using either the 'service' or 'systemctl' command
# Currently only supports RH/CentOS 6/7 hosts
sub getServices()
{
    $systemd = 1 if (-e "/usr/bin/systemctl"); 
    foreach my $s (@services)
    {
    	$enable = 0;
    	if ($systemd)
    	{
    		$res = `/usr/bin/systemctl status $s`;
    		$enabled = 1 if ($res =~ /Loaded: loaded.*enabled/);
    	}
    	else
    	{
    		$res = `service $s status`;
    		$enabled = 1 if ($res =~ /is running/);
    	}
		$service{$s} = $enabled;
	}
}

sub getFile()
{
	$file = shift;
	return "" if (!defined($files->{$file}->{'path'}));
	if ($files->{$file}->{'type'} eq "db")
	{
		tie %content,"DB_File",$files->{$file}->{'path'},O_RDONLY,0666,$DB_HASH;
		$jsonobj = JSON->new->allow_nonref;
	    $res = $jsonobj->encode(\%content);
	    untie %content;
	}
	elsif ($files->{$file}->{'type'} eq "access")
	{
		# Sendmail 'access'-style text file. Treat each line as a key/value pair and convert to json
		my %content;
		open(IN,$files->{$file}->{'path'});
		while(<IN>)
		{
			next if (/^#/);
			chomp;
			($key,$val) = split(/\s+/,$_,2);
			$content{$key} = $val;
		}
		close IN;
		$jsonobj = JSON->new->allow_nonref;
	    $res = $jsonobj->encode(\%content);
	}
	return $res;
}